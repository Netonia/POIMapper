import { _computingFeliciaLanguage, _contentToChart, _is } from "../helper/felicia.js"; let renderingPointCollection = [], tooltipPointCollection = [], _renderType = "circleMarker", _classAppearanceSymbolsByAttributes = [], _classAppearanceTooltipsByAttributes = [], _defaultCircleMarker = { radius: 15, color: "#22ffff", weight: 4, fillColor: "#28ffff", opacity: .75 }; export const _initializationOfRendering = e => { _renderType = e }; export const _resetOfRendering = () => { _classAppearanceSymbolsByAttributes = [], _classAppearanceTooltipsByAttributes = [] }; export const _settingsOfRendering = (e, t) => { if (0 === e.length) return; const o = e.map((e => e.guid)), i = _classAppearanceSymbolsByAttributes.filter((e => -1 === o.indexOf(e.guid))); _classAppearanceSymbolsByAttributes = [...i, ...e], renderingPointCollection.forEach((e => { const o = _classAppearanceSymbolsByAttributes.filter((t => t.guid === e.guid)), i = renderingPointCollection.filter((t => t.guid === e.guid)); if (0 !== i.length && 0 !== o.length) if (void 0 !== o[0].symbol.iconUrl) { let n = t.icon(o[0].symbol), r = t.marker([e.latitude, e.longitude], { icon: n }); r.guid = e.guid, __changeToIconFromGroupLayerMethod(i, r) } else void 0 !== o[0].symbol.radius && i.map((n => { if (void 0 !== n.marker.options.radius) n.marker.setStyle(o[0].symbol); else { let n = new t.circleMarker([e.latitude, e.longitude], o[0].symbol); n.guid = e.guid, __changeToIconFromGroupLayerMethod(i, n) } })) })); const n = _createSymbolsForLegend(_pointsLayersGroup); return { points: _classAppearanceSymbolsByAttributes, symbols: n } }; const _createSymbolsForLegend = e => e.map((e => { const t = Object.values(e._layers), o = t.map((e => e.options)); return { type: e.type, guids: t.map((e => e.guid)), coordinates: t.map((e => [e._latlng.lat, e._latlng.lng])), symbol: 0 !== o.length && void 0 === o[0].icon ? o[0] : null, icon: 0 !== o.length ? void 0 === o[0].icon ? null : o[0].icon.options : null } })), __replaceInToArrayPrototype = (e, t) => e.map((e => e.guid === t.guid ? t : e)), __changeToIconFromGroupLayerMethod = (e, t) => { e.forEach((e => { _pointsLayersGroup.forEach((o => o.eachLayer((i => { i.guid === e.guid && (o.removeLayer(i), o.addLayer(t)) })))), renderingPointCollection = renderingPointCollection.map((o => { if (e.guid === o.guid) { let e = o; return e.marker = t, e } return o })) })) }; export const _settingsOfTooltips = (e, t) => { const o = e.map((e => _is(e.tooltip.content, "chart"))), i = e.map((e => e.guid)), n = _classAppearanceTooltipsByAttributes.filter((e => -1 === i.indexOf(e.guid))); _classAppearanceTooltipsByAttributes = [...n, ...e], -1 !== o.indexOf(!0) && t.on("tooltipopen", (e => { _is(e.tooltip._content, "chart") && void 0 !== e && void 0 !== e.tooltip && void 0 !== e.tooltip._content && _contentToChart(e.tooltip._content) })), __settingOrChangeTooltips() }; const __settingOrChangeTooltips = () => { _classAppearanceTooltipsByAttributes.forEach((e => { const t = renderingPointCollection.filter((t => t.guid == e.guid)); if (1 === t.length) { const o = t[0]; let i = _computingFeliciaLanguage(o, e.tooltip.content); e.tooltip.permanent ? o.marker.bindTooltip(i, { opacity: e.tooltip.opacity, permanent: e.tooltip.permanent }).openTooltip() : o.marker.bindTooltip(i, { opacity: e.tooltip.opacity, permanent: e.tooltip.permanent }), null !== e.tooltip.content && (_is(e.tooltip.content, "chart") && e.tooltip.permanent) && _contentToChart(i) } })) }, __settingOrChangeTooltip = e => { _classAppearanceTooltipsByAttributes.filter((t => t.guid == e)).forEach((t => { const o = renderingPointCollection.filter((t => t.guid === e)); if (1 === o.length) { const e = o[0]; let i = _computingFeliciaLanguage(e, t.tooltip.content); e.marker.setTooltipContent(i) } })) }; export const _emptyStreamPointCollection = () => { renderingPointCollection = [], tooltipPointCollection = [] }; export const _addPointToCollection = (e, t, o) => { if (!_pointValidateAndMessages(e)) return; let i = new o.marker([e.latitude, e.longitude], { opacity: 1 }); e.guid, e.type, e.value, e.latitude, e.longitude; i.addTo(t) }; export const _settingDisplayCluster = e => { displayCluster = e }; export const _settingClusteringConfig = e => { _clusteringConfiguration = e }; export let _pointsLayersGroup = []; let displayCluster = !1, _clusteringConfiguration = null; export const _addPointsToCollection = (e, t, o, i, n) => { if (t && (renderingPointCollection = [], _pointsLayersGroup = []), !Array.isArray(e)) throw console.warm("is not Array points"), Error("is not Array points"); if (!_pointsValidateAndMessages(e)) throw console.warm("point(s) in Array is/are not valid"), Error("point(s) in Array is/are not valid"); let r = e.map((e => { let t = {}; if ("circleMarker" === _renderType) { const o = _classAppearanceSymbolsByAttributes.filter((t => t.guid === e.guid)); t = new i.circleMarker([e.latitude, e.longitude], 0 !== o.length ? o[0].symbol : _defaultCircleMarker), t.guid = e.guid } else "marker" === _renderType && (t = new i.marker([e.latitude, e.longitude], { opacity: 1 })); return { guid: e.guid, marker: t, type: e.type, value: e.value, latitude: e.latitude, longitude: e.longitude, timestamp: new Date } })); renderingPointCollection = [...renderingPointCollection, ...r]; const l = Object.values(o._layers).filter((e => void 0 !== e.type)), a = r.filter((e => -1 !== l.map((e => e.type)).indexOf(e.type))), s = r.filter((e => -1 === l.map((e => e.type)).indexOf(e.type))); let d = null; if (0 !== s.length) { let e = null; if (displayCluster) { e = null === _clusteringConfiguration ? i.markerClusterGroup() : i.markerClusterGroup(_clusteringConfiguration), null != n && e.on("clusterclick", (e => { const t = e.layer.getAllChildMarkers().map((e => e.guid)), o = e.layer.getBounds(); let i = { northEast: { latitude: 0, longitude: 0 }, southWest: { latitude: 0, longitude: 0 } }; o.isValid() && (i.northEast.latitude = o._northEast.lat, i.northEast.longitude = o._northEast.lng, i.southWest.latitude = o._southWest.lat, i.southWest.longitude = o._southWest.lng), n.invokeMethodAsync("onClusterClickTrigger", { location: { latitude: e.latlng.lat, longitude: e.latlng.lng }, guids: t, bounds: i }) })); const t = s.map((e => e.marker)); e.addLayers(t) } else e = i.layerGroup(s.map((e => e.marker))); e.type = 0 !== r.length ? r[0].type : "not exist", d = e, _pointsLayersGroup.push(e), e.addTo(o) } return 0 !== a.length && l.forEach((e => { const t = e.type; a.forEach((o => { o.type === t && e.addLayer(o.marker), d = e })) })), { layer: d, renderingPointCollection: renderingPointCollection } }; export const _updateAttribute = (e, t, o) => (_updateCollections(e, renderingPointCollection, _pointsLayersGroup, t, o), { symbols: _createSymbolsForLegend(_pointsLayersGroup), layers: _pointsLayersGroup }); const _updateCollections = (e, t, o, i, n) => { let r = t.findIndex((t => t.guid === e.guid)), l = null; if (-1 === r) t.push(e); else { let o = t[r]; if (l = { ...o }, o.type === e.type) t[r].value = e.value; else { let o = t.find((t => t.type === e.type))?.marker || null, i = { ...e, marker: o }; t[r] = i, e = i } } let a = null, s = -1, d = -1, p = 0; for (let t of o) { let o = t._layers, i = 0; for (let n of Object.keys(o)) { if (o[n].guid === e.guid) { a = t, s = p, d = n; break } i++ } if (a) break; p++ } if (a) if (a.type === e.type); else if (delete a._layers[d], 0 === Object.keys(a._layers).length) { let e = 0; for (let t of o) 0 === Object.keys(t._layers).length && o.splice(e, 1), e++; a = null } let u = o.find((t => t.type === e.type)); if (u) u.addLayer(l.marker); else { let t = n.layerGroup([l.marker], e.type); t.type = e.type, o.push(t), t.addTo(i) } }; export const _addPointsOnType = (e, t, o, i) => { if (t && (renderingPointCollection = [], _pointsLayersGroup = []), !Array.isArray(e)) throw console.warm("is not Array points"), Error("is not Array points"); if (!_pointsValidateAndMessages(e)) throw console.warm("point(s) in Array is/are not valid"), Error("point(s) in Array is/are not valid"); let n = e.map((e => { let t = new i.marker([e.latitude, e.longitude], { opacity: 1 }); return { guid: e.guid, marker: t, type: e.type, value: e.value } })); renderingPointCollection = [...renderingPointCollection, ...n]; let r = i.layerGroup(renderingPointCollection.map((e => e.marker))); _pointsLayersGroup.push(r), r.addTo(o) }; export const _clearAllPointsCollection = e => { for (let t of _pointsLayersGroup) e.removeLayer(t); renderingPointCollection = [], tooltipPointCollection = [] }; export const _clearPointsByIdsCollection = (e, t) => { const o = renderingPointCollection.filter((t => -1 !== e.indexOf(t.guid))), i = renderingPointCollection.filter((t => -1 === e.indexOf(t.guid))); o.forEach((e => { t.removeLayer(e.marker) })), renderingPointCollection = i }; export const _removePoints = (e, t) => { }; export const _removeType = (e, t) => { }; export const _movePointFromCollection = (e, t, o) => { if (!_pointValidateAndMessages(e)) return; e.guid; let i = renderingPointCollection.filter((t => t.guid === e.guid)); if (1 !== i.length) throw 0 === i.length ? (console.warn("id(s) does not exist in the Geometric.Points collection"), Error("id(s) does not exist in the Geometric.Points collection")) : (console.warn("Duplicated in the collection of points of Geometric.Points"), Error("Duplicated in the collection of points of Geometric.Points")); { let t = i[0].marker, r = i[0].type, l = i[0].value; e.type === r && e.value === l || console.warn("You cannot change type and/or value using the moveTo method, sorry!"); var n = o.latLng(e.latitude, e.longitude); t.setLatLng(n), t.latitude = e.latitude, t.longitude = e.longitude, t.timestamp = new Date } }; const _pointValidateAndMessages = e => { let t = !0; if (null == e) throw console.warm("Point is not valid"), Error("Point is not valid"); if (void 0 === e.latitude || null === e.latitude) throw console.warm("latiude value is not valid"), Error("latiude value is not valid"); if (void 0 === e.longitude || null === e.longitude) throw console.warm("longitude value is not valid"), Error("longitude value is not valid"); if ("number" != typeof e.latitude || "number" != typeof e.longitude) throw console.warm("longitude and/or latitude value is not a number"), Error("longitude and/or latitude value is not a number"); return t }, _pointsValidateAndMessages = e => { for (let t of e) if (!_pointValidateAndMessages(t)) return !1; return !0 }; export function _asa_trebuie_facuta_scalarea_layerelor(e, t) { let o = 1e4, i = 0; if ("undefined" != typeof symbology && null !== symbology && void 0 !== symbology.scaling && null !== symbology.scaling) { let e = symbology.scaling; void 0 !== e.start_with && null !== e.start_with && (i = parseInt(e.start_with)), void 0 !== e.stop_with && null !== e.stop_with && (o = parseInt(e.stop_with)) } !1 == (0 === i && 1e4 === o) && t.on("zoomend", (function () { parseInt(t.getZoom()) >= i && parseInt(t.getZoom()) <= o ? t.addLayer(layer) : t.removeLayer(layer) })) }